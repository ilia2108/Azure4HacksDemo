# Azure for Hacks demo
В этой демонстрации будет расссмотрен один из классических сценариев приминения Azure на хакатонах.
# Требования
Для реализации сценария нам понадобятся:
* Базовое понимание языка **C#**
* Понимание основных **принципов создания архитектуры** проектов
* **Активная подписка в Microsoft Azure**. Если ее нет, то ее необходимо создать (детали [здесь](https://habr.com/ru/company/microsoft/blog/352786/ "Как получить подписку Microsoft Azure?"))
# Описание проекта
Мы разберем проект команды **MySUitTOP** (лучшая команда в Москве). Их задача состоит в создании сервиса, способного помочь в проверке письменных работ. Им необходимо подсчитать количество слов и предложений. Если текст соответствует базовым условиям экзамена, то необходимо произвести анализ текста (тональность текста, ключевые слова и т.д.).
# Архитектура
Так как с экзаменами сталкивается огромное количество людей, то необходимо очень серьезно отнестись к архитектуре. Одним из приоритетов является **масштабируемость** мощностей под нагрузки. Поэтому ребята приняли решение использовать **микросервисный** подход. Они решили выстроить свой проект следующим образом:

* Клиент вводит текст, используя приложение на базе Xamarin Forms
* Приложение делает единственный REST запрос к Azure Logic App, передавая JSON файл с именем и фамилией, возрастом и текстом работы. 
    * Logic App делает еще один запрос на базовую проверку текста, которая реализована в Function App.
    * Если результат проверки положительный, то в базу данных работ добавляется новая строчка с данными, которые были высланы ранее. В случае отрицательного результата будет отправлен ответ со статусом 406. 
    * После успешного добавления в базу данных отправится ответ со статусом 200 и ID нового добавленного элемента в базу данных.

Иначе говоря, архитектуру можно было представить так:
![alt text](https://github.com/ilia2108/Azure4HacksDemo/blob/master/PhotosForRepo/arch.png "Architecture")

# Вариант 1. Хакатонный вариант
Здесь мы рассмотрим вариант "на скорую руку". На хакатонах важно делать упор на скорость, поэтому здесь присутствуют некоторые архитектурные допущения (которые мы исправим во втором варианте).
## Шаг 1. Создание ресурсов
Для начала нам необходимо создать все ресурсы, упомянутые выше. Если быть точным, нам необходимо создать:
* [**Базу данных SQL**](https://docs.microsoft.com/ru-ru/azure/sql-database/sql-database-single-database-get-started?tabs=azure-portal "SQL DB")
    * Прописать правило фаервола AllIpAddresses с начальным адресом 0.0.0.0 и конечным 255.255.255.255 *(все ли тут в порядке?)*
* [**Function App**](https://docs.microsoft.com/ru-ru/azure/azure-functions/functions-create-your-first-function-visual-studio "Azure Functions") на базе .NET Core 3.1
* [**Logic App**](https://docs.microsoft.com/ru-ru/azure/logic-apps/quickstart-create-first-logic-app-workflow "Logic App")

## Шаг 2. Настраиваем БД
В базе данных надо создать таблицу **TEXTS** с полями
* *ID* - Integer, Primary Key
* *FIRST_NAME* - Varchar(20)
* *SECOND_NAME* - Varchar(20)
* *AGE* - Integer
* *EXAM_TEXT* - VARCHAR(1000)

## Шаг 3. Настраиваем Logic App
* Настраиваем входящий JSON
* Делаем запрос в Function App
* Добавляем условие по результату запроса в Function App
* Настраиваем БД
    * Добавляем коннектор на добавление строки в SQL Server
    * Вводим данные сервера и имя БД
    * вбиваем ранее полученные данные

## Шаг 4. Тестируем с помощью Postman
Далее мы должны **сохранить** Logic App и скопировать ссылку из первого шага приложения. Далее надо открыть Postman и попытаться протестировать запрос. Если все работает, то добавить эту ссылку в ранее разработанное UWP приложение.

# Вариант 2. Более правильный
В нашей архитектуре есть одна неточность, которая появилась по ходу разработки. Выяснилось, что SQL DB принимает запросы со всех адресов в публичной сети, что является **критической уязвимостью**.